os.loadAPI('apis/mat')
id = 0

function createInterface(opts)
	if type(opts) ~= 'table' then error('You must specify a routes table') end

	if type(opts.routes) ~= 'table' then error('You must pass a valid routes table, got: ' .. type(opts.routes)) end

	local inter = { type = 'lo' }

	inter.name = inter.type .. tostring(id)
	id = id + 1

	local routes = opts.routes

	routes[mat.createNetwork(mat.parse('127::/8'))] = inter

	local daemons = {}
	local runningDaemons = {}

	function inter.addDaemon(name, fn)
		if type(fn) ~= 'function' then
			return false
		end

		daemons[name] = fn

		return true
	end

	function inter.startDaemon(name)
		local fn = daemons[name]

		-- Not really necessary
		-- if type(fn) ~= 'function' then return false end

		logging.debug('Starting Daemon: ' .. name)

		local daemon = coroutine.create(fn)
		runningDaemons[name] = daemon
		utils.erroredResume(daemon, inter)

		return true
	end

	function inter.stopDaemon(name)
		local daemon = runningDaemons[name]

		-- Handle daemons that aren't started
		if type(daemon) ~= 'thread' then return true end

		logging.debug('Stopping Daemon: ' .. name)

		utils.erroredResume(daemon, { 'lcp', {
			command = 'daemon:stop'
		} })

		if coroutine.status(daemon) == 'dead' then
			runningDaemons[name] = nil
		else
			logging.warn(name .. ' didn\'t stop when told to')

			return false
		end

		return true
	end

	function inter.stop()
		for name in pairs(daemons) do
			if type(runningDaemons[name]) == 'thread' and not inter.stopDaemon(name) then return false end
		end

		return true
	end

	function inter.send(packet)
		for _, daemon in pairs(runningDaemons) do
			coroutine.resume(daemon, 'network', packet)
		end
	end

	function inter.checkEvent() return false end
	function inter.handleEvent() return false end
	function inter.run() return true end

	return inter
end