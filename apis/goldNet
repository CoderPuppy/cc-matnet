os.loadAPI('apis/stoneNet')
os.loadAPI('apis/utils')
os.loadAPI('apis/logging')
os.loadAPI('apis/mat')

function create(opts)
	if type(opts) ~= 'table' then error('You must specify modem, side, matables and routes') end

	local net = {}
	local stone = stoneNet.create(opts)
	local daemons = {}
	local runningDaemons = {}
	local mat = '::'

	function net.addDaemon(name, fn)
		if type(fn) ~= 'function' then
			error('Must supply a function when registering a daemon')
		end

		daemons[name] = fn

		return true
	end

	function net.run()
		stone.run()

		stone.startDaemon('goldenDaemons')
	end

	function net.stop()
		for name in pairs(daemons) do
			if type(runningDaemons[name]) == 'thread' and not net.stopDaemon(name) then return false end
		end

		if not stone.stopDaemon('goldenDaemons') then return false end

		if not stone.stop() then return false end

		return true
	end

	function net.startDaemon(name)
		local fn = daemons[name]

		-- Not really necesary
		-- if type(fn) ~= 'function' then return false end

		logging.log('Starting Daemon: ' .. name)

		local daemon = coroutine.create(fn)
		runningDaemons[name] = daemon
		utils.erroredResume(daemon, mat)


		return true
	end

	function net.stopDaemon(name)
		local daemon = runningDaemons[name]

		-- Handle daemons that aren't started
		if type(daemon) ~= 'thread' then return true end

		logging.log('Stopping Daemon: ' .. name)

		utils.erroredResume(daemon, { 'lcp', {
			command = 'daemon:stop'
		} })

		if coroutine.status(daemon) == 'dead' then
			runningDaemons[name] = nil
		else
			logging.warn(name .. ' didn\'t stop when told to')

			return false
		end

		return true
	end

	function net.handle(ev)
		return stone.handle(ev)
	end

	function net.checkEvent(ev) return stone.checkEvent(ev) end

	function net.genFrame(packet)
		if packet.frame then return packet.frame end

		local frame = {
			to = routes.get(packet.to),
			from = stoneNet.id
		}

		frame.data = packet

		return frame
	end

	net.stone = stone

	stone.addDaemon('goldenDaemons', function(addr)
		while true do
			local _, frame = coroutine.yield()

			if _ == 'lcp' then
				if frame.command == 'daemon:stop' then
					return
				end
			elseif _ == 'network' then
				local packet = parseFrame(frame)

				for name, daemon in pairs(runningDaemons) do
					utils.erroredResume(daemon, { 'network', packet })
				end
			end
		end
	end)

	return net
end

function createPacket(opts)
	opts = opts or {}

	local packet = {
		to = opts.to or '::',
		from = opts.from or '::',
		data = opts.data,
		type = opts.type
	}
	
	return packet
end

function parseFrame(frame)
	local packet = {}
	local data = frame.data

	packet.to = data.to
	packet.from = data.from
	packet.data = data.data
	packet.type = data.type
	packet.frame = frame

	return packet
