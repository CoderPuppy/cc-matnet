os.loadAPI('apis/stoneNet')
os.loadAPI('apis/utils')
os.loadAPI('apis/logging')
os.loadAPI('apis/mat')

function create(opts)
	if type(opts) ~= 'table' then error('You must specify matables and routes') end

	if type(opts.matables) ~= 'table' then error('You must pass a valid matable instance, got: ' .. type(opts.mataables)) end
	if type(opts.routes) ~= 'table' then error('You must pass a valid routes table, got: ' .. type(opts.routes)) end

	local mataables = opts.mataables
	local routes = opts.routes

	local net = { osPullEvent = os.pullEvent }
	local daemons = {}
	local runningDaemons = {}
	local interfaces = {}

	local function networkDaemons(inter)
		while true do
			local _, packet = coroutine.yield()

			if _ == 'lcp' then
				if packet.command == 'daemon:stop' then
					return
				end
			elseif _ == 'network' then
				for _, daemon in pairs(runningDaemons) do
					utils.erroredResume(daemon, 'network', packet)
				end
			end
		end
	end

	function net.addDaemon(name, fn)
		if type(fn) ~= 'function' then
			error('Must supply a function when registering a daemon')
		end

		daemons[name] = fn

		return true
	end

	function net.run()
		
	end

	function net.stop()
		for name in pairs(daemons) do
			if type(runningDaemons[name]) == 'thread' and not net.stopDaemon(name) then return false end
		end

		-- This is to work around next erroring when the table it's iterating is modified in an iteration
		local interNames = {}

		for name in pairs(interfaces) do
			interNames[#interNames + 1] = name
		end

		for i = 1, #interNames do
			net.close(interfaces[interNames[i]])
		end

		return true
	end

	function net.pullEvent(filter)
		while true do
			local ev = {net.osPullEvent()}
			
			if not net.handleEvent(ev) then return unpack(ev) end
		end
	end

	function net.open(inter)
		if not inter.addDaemon('networkDaemons', networkDaemons) then return false end
		if not inter.startDaemon('networkDaemons') then return false end

		interfaces[inter.name] = inter

		if not inter.run() then return false end

		return true
	end

	function net.close(inter)
		if not inter.stopDaemon('networkDaemons') then return false end
		if not inter.stop() then return false end

		interfaces[inter.name] = nil

		return true
	end

	function net.startDaemon(name)
		local fn = daemons[name]

		-- Not really necesary
		-- if type(fn) ~= 'function' then return false end

		logging.debug('Starting Daemon: ' .. name)

		local daemon = coroutine.create(fn)
		runningDaemons[name] = daemon
		utils.erroredResume(daemon, net)


		return true
	end

	function net.stopDaemon(name)
		local daemon = runningDaemons[name]

		-- Handle daemons that aren't started
		if type(daemon) ~= 'thread' then return true end

		logging.debug('Stopping Daemon: ' .. name)

		utils.erroredResume(daemon, 'lcp', {
			command = 'daemon:stop'
		})

		if coroutine.status(daemon) == 'dead' then
			runningDaemons[name] = nil
		else
			logging.warn(name .. ' didn\'t stop when told to')

			return false
		end

		return true
	end

	function net.checkEvent(ev)
		for _, inter in pairs(interfaces) do
			if inter.checkEvent(ev) then return true end
		end
		
		return false
	end

	function net.handleEvent(ev)
		local found = false

		for _, inter in pairs(interfaces) do
			if inter.handleEvent(ev) then
				found = true
			end
		end

		return found
	end

	function net.send(packet)
		local to = mat.parse(packet.to)

		routes.each(function(ma, route)
			-- print(ma.matchBits)
			-- print(mat.toString(ma), ' == ', mat.toString(to), ':')

			if mat.match(to, ma) then
				-- print('    true')
				-- print(route.inter.name)
				route.inter.send(packet, route)
			-- else
			-- 	print('    false')
			end
		end)
		end
	end

	function net.genFrame(packet)
		if packet.frame then return packet.frame end

		local frame = {
			to = routes.get(packet.to),
			from = stoneNet.id
		}

		frame.data = packet

		return frame
	end

	return net
end

function createInterface(opts)
	if type(opts) ~= 'table' then error('You must specify a low-level interface and a routes table') end

	if type(opts.inter) ~= 'table' then error('You must pass a valid low-level interface, got: ' .. type(opts.inter)) end
	if type(opts.routes) ~= 'table' then error('You must pass a valid routes table, got: ' .. type(opts.routes)) end

	local sinter = opts.inter
	local routes = opts.routes

	local inter = { type = sinter.type, name = sinter.name }

	local daemons = {}
	local runningDaemons = {}

	function inter.addDaemon(name, fn)
		if type(fn) ~= 'function' then
			return false
		end

		daemons[name] = fn

		return true
	end

	function inter.startDaemon(name)
		local fn = daemons[name]

		-- Not really necessary
		-- if type(fn) ~= 'function' then return false end

		local daemon = coroutine.create(fn)
		runningDaemons[name] = daemon
		utils.erroredResume(daemon, inter)

		return true
	end

	function inter.stopDaemon(name)
		local daemon = runningDaemons[name]

		-- Handle daemons that aren't started
		if type(daemon) ~= 'thread' then return true end

		utils.erroredResume(daemon, 'lcp', {
			command = 'daemon:stop'
		})

		if coroutine.status(daemon) == 'dead' then
			runningDaemons[name] = nil
		else
			logging.warn(name .. ' didn\'t stop when told to')

			return false
		end

		return true
	end

	function inter.run()
		if not sinter.run() then return false end
		if not sinter.startDaemon('golden') then return false end

		return true
	end

	function inter.send(packet, route)
		sinter.send({
			to = route.id or -1,
			from = sinter.id,
			data = packet,
			type = 'golden'
		})
	end

	function inter.stop()
		-- Loop through daemons because inside it modifies runningDaemons which crashes next
		for name in pairs(daemons) do
			if not inter.stopDaemon(name) then return false end
		end

		if not sinter.stop() then return false end

		return true
	end

	function inter.checkEvent(ev) return sinter.checkEvent(ev) end
	function inter.handleEvent(ev) return sinter.handleEvent(ev) end

	sinter.addDaemon('golden', function(inter)
		while true do
			local _, frame = coroutine.yield()

			if _ == 'lcp' then
				if frame.command == 'daemon:stop' then
					return
				end
			elseif _ == 'link' and frame.type == 'golden' then
				local packet = frame.data

				for name, daemon in pairs(runningDaemons) do
					utils.erroredResume(daemon, 'network', packet)
				end
			end
		end
	end)

	return inter
end

function createPacket(opts)
	opts = opts or {}

	local packet = {
		to = opts.to or '::',
		from = opts.from or '::',
		data = opts.data,
		type = opts.type
	}
	
	return packet
end

function parseFrame(frame)
	local packet = {}
	local data = frame.data

	packet.to = data.to
	packet.from = data.from
	packet.data = data.data
	packet.type = data.type
	packet.frame = frame

	return packet
end