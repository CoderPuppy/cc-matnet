os.loadAPI('apis/logging')

local matParts = 4
local matSize = 32

function validateMAT(mat, silent)
	local warn

	if silent then
		warn = function(msg)
			logging.warn(msg)
		end
	else
		warn = function(msg)
			error(msg)
		end
	end

	if type(mat) ~= 'table' then warn('MAT address must be in table form, got: ' .. type(mat)) return false end
	if type(mat.parts) ~= 'table' then warn('MAT address must have parts, got: ' .. type(mat.parts)) return false end
	if #mat.parts ~= matParts then warn('MAT address must have 4 parts, got: ' .. #mat.parts) return false end

	-- Check all the parts of the MAT address
	for i = 1, matParts do
		if mat.parts[i] > 255 then
			warn('MAT address parts cannot be greater than 255, #' .. tostring(i) .. ': ' .. tostring(mat.parts[i]))
			return false
		elseif mat.parts[i] < 0 then
			warn('MAT address parts cannot be less than 0, #' .. tostring(i) .. ': ' .. tostring(mat.parts[i]))
			return false
		end
	end

	if type(mat.netBits) == 'number' and mat.netBits > matSize then warn('Netmasks cannot be longer than ' .. tostring(matSize) .. ', got: ' .. tostring(mat.netBits)) end
	if type(mat.netBits) == 'number' and mat.netBits < 0 then warn('Netmasks cannot be negative, got: ' .. tostring(mat.netBits)) end
end

function parse(mat)
	local m, subnetStart

	local mata = {
		matchBits = matSize
	}

	-- Match the subnet
	m = {mat:find('/(%d+)$')}

	if m[1] and #m == 3 then
		mata.matchBits = tonumber(m[3])
		mat = mat:sub(1, m[1] - 1)
	end

	local matArr = utils.split(mat, ':')
	local expanderFound = false
	local outofRow = false
	local expander
	local remove = 0

	-- print(textutils.serialize(matArr))

	-- Find extra blank values (Can't remove them here because of a bug with LuaJ)
	for i, v in ipairs(matArr) do
		if v == '' then
			if not expanderFound then
				expanderFound = true
				expander = i
			elseif outofRow then
				error('More than one expander in MAT address')
			else
				remove = remove + 1
			end
		else
			if expanderFound and not outofRow then
				outofRow = true
			end
		end
	end

	-- Remove them
	if expanderFound then
		for _=1,remove do
			table.remove(matArr, expander)
		end
	end

	-- Expand the expander
	local newMatArr = {}

	-- if expanderFound and #matArr < matParts then
		for i, v in pairs(matArr) do
			if v == '' then
				for _ = 1,(matParts - (#matArr - 1)) do
					table.insert(newMatArr, 0)
				end
			else
				table.insert(newMatArr, tonumber(v))
			end
		end
		-- if expanderFound then
			-- utils.table_slice(newMatArr, 1, expander - 1)
		-- end
	-- end

	mata.parts = newMatArr

	validateMAT(mata)

	return mata
end

function toString(mata)
	local expander = false
	local expanderLoc
	local expanderNum
	local outofRow = false
	local foundZero = false

	validateMAT(mata)

	-- Find where to put an expander
	for i, v in ipairs(mata.parts) do
		if v == 0 then
			if expander and not outofRow then
				expanderNum = expanderNum + 1
			elseif not expander and foundZero then
				expander = true
				expanderNum = 2
				outofRow = false
				foundZero = false
			elseif not expander and not foundZero then
				foundZero = true
				expanderLoc = i
			end
		else
			outofRow = true
		end
	end

	local res

	if expander then
		-- Get the parts before the expander
		res = table.concat(utils.table_slice(mata.parts, 1, expanderLoc - 1), ':') ..
		       '::' ..
		       -- Get the parts after the expander
		       table.concat(utils.table_slice(mata.parts, expanderLoc + expanderNum), ':')
	else
		res = table.concat(mata.parts, ':')
	end

	-- Add the net bits to the end
	if type(mata.matchBits) == 'number' and mata.matchBits ~= matSize then
		res = res .. '/' .. tostring(mata.matchBits)
	end

	return res
end

-- MAT Address Syntax
-- 4 sections each 1 byte long
-- :: expands to as many 0s as necesary
-- /<num> specify how many bits to include in the subnet mask
-- Examples:
-- :: blank mat
-- 127::/8 localhost subnet (gos into the local buffer)
-- 10::/8 private network subnet (these are the mats that computers on private networks should get)
-- 10::1 private network router
-- 224::/8 multicast subnet
-- 240:255::/8 dev subnet ->
--   240:255:224:0/24 multicast dev subnet

function createAddrMask(bits)
	if bits > matSize then error('Netmasks cannot be larger than ' .. tostring(matSize) .. ' got: ' .. tostring(bits)) end

	return bit.blshift(2^bits - 1, matSize - bits)
end

function createMatcher(mat)
	validateMAT(mat)

	if type(mat.matchBits) ~= 'number' then error('Match bits are required for creating a matcher, got: ' .. type(mat.matchBits)) end

	local addr = { mask = createAddrMask(mat.matchBits), parts = mat.parts, matchBits = mat.matchBits }

	addr.matchNum = bit.band(addr.mask, toNum(mat))

	return addr
end

function match(input, matcher)
	validateMAT(input)
	validateMAT(matcher)
	
	if (type(matcher.matchNum) ~= 'number' or type(matcher.mask ~= 'number')) and type(matcher.matchBits) == 'number' then
		matcher = createMatcher(matcher)
	end
	if type(matcher.matchBits) == 'number' then
		return bit.band(toNum(input), matcher.mask) == matcher.matchNum
	end

	return toNum(input) == toNum(matcher)
end

function toNum(mat)
	validateMAT(mat)
	return bit.blshift(mat.parts[1], 24) + bit.blshift(mat.parts[2], 16) + bit.blshift(mat.parts[3], 8) + mat.parts[4]
end

undefined = createMatcher(parse('::'))

function wrap(mat)
	if type(mat) == 'string' then
		return parse(mat)
	elseif type(mat) == 'table' and type(mat.parts) == 'table' and #mat.parts == matParts then
		return mat
	end
end