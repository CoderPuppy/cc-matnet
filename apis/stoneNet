id = os.getComputerID()

os.loadAPI('apis/logging')
os.loadAPI('apis/utils')

function create(opts)
	if type(opts) ~= 'table' then error('You must specify modem, side and matables') end

	if type(opts.modem) ~= 'table' then error('You must pass a valid modem, got: ' .. type(opts.modem)) end
	if type(opts.channel) ~= 'number' then error('Channel must be a number, got: ' .. type(opts.channel)) end
	if opts.channel <= 0 then error('Channel must be greater than 0, got: ' .. tostring(opts.channel)) end
	if opts.channel >= 65535 then error('Channel must be less than 65535, got: ' .. tostring(opts.channel)) end
	if type(opts.matables) ~= 'table' then error('You must pass a valid matable instance, got: ' .. type(opts.matables)) end

	local net = {}
	local daemons = {}
	local runningDaemons = {}

	function net.addDaemon(name, fn)
		if type(fn) ~= 'function' then
			return false
		end

		daemons[name] = fn

		return true
	end

	function net.checkEvent(ev)
		if ev[1] == 'modem_message' and ev[2] == side and ev[3] == channel then
			return true
		end

		return false
	end

	function net.run()
		return true
	end

	function net.stop()
		for name in pairs(daemons) do
			if type(runningDaemons[name]) == 'thread' and not net.stopDaemon(name) then return false end
		end

		return true
	end

	function net.startDaemon(name)
		local fn = daemons[name]

		-- Not really necessary
		-- if type(fn) ~= 'function' then return false end

		local daemon = coroutine.create(fn)
		runningDaemons[name] = daemon
		utils.erroredResume(daemon, id)

		return true
	end

	function net.stopDaemon(name)
		local daemon = runningDaemons[name]

		-- Handle daemons that aren't started
		if type(daemon) ~= 'thread' then return true end

		utils.erroredResume(daemon, { 'lcp', {
			command = 'daemon:stop'
		} })

		if coroutine.status(daemon) == 'dead' then
			runningDaemons[name] = nil
		else
			logging.warn(name .. ' didn\'t stop when told to')

			return false
		end

		return true
	end

	function net.handle(ev)
		if not net.checkEvent(ev) then return false end

		local frame = parseEvent(ev)

		for name, daemon in pairs(runningDaemons) do
			utils.erroredResume(daemon, frame)
		end

		return true
	end

	return net
end

function parseEvent(ev)
	local frame = {}
	local data = textutils.unserialize(ev[5]) -- This should change

	frame.to = data.to
	frame.from = data.from
	frame.data = data.data
	frame.type = data.type
	frame.channel = ev[2]
	frame.event = ev

	return frame
end