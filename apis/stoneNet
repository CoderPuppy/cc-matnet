id = os.getComputerID()

os.loadAPI('apis/logging')
os.loadAPI('apis/utils')

local interID = 0

function createInterface(opts)
	if type(opts) ~= 'table' then error('You must specify side, channel and matables') end

	if type(opts.side) ~= 'string' then error('You must pass a valid side, got: ' .. type(opts.side)) end

	do
		local ok, res = pcall(peripheral.getType, opts.side)

		if (not ok and res:sub(#res - 12) == 'Invalid side.') or res == nil then
			error('You must pass a valid side (left, right, top, bottom, front, back), got: ' .. opts.side)
		elseif ok and res ~= 'modem' then
			error('There must be a modem on the "' .. opts.side .. '", got: ' .. res)
		end
	end

	if type(opts.channel) ~= 'number' then error('Channel must be a number, got: ' .. type(opts.channel)) end
	if opts.channel <= 0 then error('Channel must be greater than 0, got: ' .. tostring(opts.channel)) end
	if opts.channel >= 65535 then error('Channel must be less than 65535, got: ' .. tostring(opts.channel)) end
	if type(opts.matables) ~= 'table' then error('You must pass a valid matable instance, got: ' .. type(opts.matables)) end

	local modem = peripheral.wrap(opts.side)
	local channel = opts.channel

	local inter = { id = id, type = 'eth' }
	local daemons = {}
	local runningDaemons = {}

	inter.name = inter.type .. tostring(interID)
	interID = interID + 1

	function inter.addDaemon(name, fn)
		if type(fn) ~= 'function' then
			return false
		end

		daemons[name] = fn

		return true
	end

	function inter.checkEvent(ev)
		if ev[1] == 'modem_message' and ev[2] == side and ev[3] == channel then
			return true
		end

		return false
	end

	local running = false

	function inter.run()
		if running then return true end

		modem.open(channel)

		running = modem.isOpen(channel)

		return running
	end

	function inter.stop()
		for name in pairs(daemons) do
			if type(runningDaemons[name]) == 'thread' and not inter.stopDaemon(name) then return false end
		end

		modem.close(channel)

		if modem.isOpen(channel) then return false end

		return true
	end

	function inter.checkEvent(ev)
		return ev[1] == 'modem_message' and ev[2] == opts.side and ev[3] == opts.channel
	end

	function inter.startDaemon(name)
		local fn = daemons[name]

		-- Not really necessary
		-- if type(fn) ~= 'function' then return false end

		logging.debug('Starting Daemon: ' .. name)

		local daemon = coroutine.create(fn)
		runningDaemons[name] = daemon
		utils.erroredResume(daemon, inter)

		return true
	end

	function inter.stopDaemon(name)
		local daemon = runningDaemons[name]

		-- Handle daemons that aren't started
		if type(daemon) ~= 'thread' then return true end

		logging.debug(inter.name .. ': Stopping Daemon: ' .. name)

		utils.erroredResume(daemon, { 'lcp', {
			command = 'daemon:stop'
		} })

		if coroutine.status(daemon) == 'dead' then
			runningDaemons[name] = nil
		else
			logging.warn(name .. ' didn\'t stop when told to')

			return false
		end

		return true
	end

	function inter.handleEvent(ev)
		if not inter.checkEvent(ev) then return false end

		local frame = parseEvent(ev)

		for name, daemon in pairs(runningDaemons) do
			utils.erroredResume(daemon, frame)
		end

		return true
	end

	function inter.send(frame)
		modem.transmit(channel, channel, genMsg(frame))
	end

	return inter
end

function genMsg(frame)
	return textutils.serialize(frame)
end

function parseEvent(ev)
	local frame = {}
	local data = textutils.unserialize(ev[5]) -- This should change

	frame.to = data.to
	frame.from = data.from
	frame.data = data.data
	frame.type = data.type
	frame.channel = ev[2]
	frame.event = ev

	return frame
end