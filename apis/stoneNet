id = os.getComputerID()

os.loadAPI('apis/logging')
os.loadAPI('apis/utils')

function createInterface(opts)
	if type(opts) ~= 'table' then error('You must specify modem, side and matables') end

	if type(opts.modem) ~= 'table' then error('You must pass a valid modem, got: ' .. type(opts.modem)) end
	if type(opts.channel) ~= 'number' then error('Channel must be a number, got: ' .. type(opts.channel)) end
	if opts.channel <= 0 then error('Channel must be greater than 0, got: ' .. tostring(opts.channel)) end
	if opts.channel >= 65535 then error('Channel must be less than 65535, got: ' .. tostring(opts.channel)) end
	if type(opts.matables) ~= 'table' then error('You must pass a valid matable instance, got: ' .. type(opts.matables)) end

	local inter = { id = id }
	local daemons = {}
	local runningDaemons = {}

	local modem = opts.modem
	local channel = opts.channel

	function inter.addDaemon(name, fn)
		if type(fn) ~= 'function' then
			return false
		end

		daemons[name] = fn

		return true
	end

	function inter.checkEvent(ev)
		if ev[1] == 'modem_message' and ev[2] == side and ev[3] == channel then
			return true
		end

		return false
	end

	function inter.run()
		return true
	end

	function inter.stop()
		for name in pairs(daemons) do
			if type(runningDaemons[name]) == 'thread' and not inter.stopDaemon(name) then return false end
		end

		return true
	end

	function inter.startDaemon(name)
		local fn = daemons[name]

		-- Not really necessary
		-- if type(fn) ~= 'function' then return false end

		logging.debug('Starting Daemon: ' .. name)

		local daemon = coroutine.create(fn)
		runningDaemons[name] = daemon
		utils.erroredResume(daemon, inter)

		return true
	end

	function inter.stopDaemon(name)
		local daemon = runningDaemons[name]

		-- Handle daemons that aren't started
		if type(daemon) ~= 'thread' then return true end

		logging.debug('Stopping Daemon: ' .. name)

		utils.erroredResume(daemon, { 'lcp', {
			command = 'daemon:stop'
		} })

		if coroutine.status(daemon) == 'dead' then
			runningDaemons[name] = nil
		else
			logging.warn(name .. ' didn\'t stop when told to')

			return false
		end

		return true
	end

	function inter.handle(ev)
		if not inter.checkEvent(ev) then return false end

		local frame = parseEvent(ev)

		for name, daemon in pairs(runningDaemons) do
			utils.erroredResume(daemon, frame)
		end

		return true
	end

	function inter.send(frame)
		modem.transmit(channel, channel, genMsg(frame))
	end

	return inter
end

function genMsg(frame)
	return textutils.serialize(frame)
end

function parseEvent(ev)
	local frame = {}
	local data = textutils.unserialize(ev[5]) -- This should change

	frame.to = data.to
	frame.from = data.from
	frame.data = data.data
	frame.type = data.type
	frame.channel = ev[2]
	frame.event = ev

	return frame
end